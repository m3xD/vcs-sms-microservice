// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.26.0
// source: server.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createServer = `-- name: CreateServer :one
INSERT INTO servers (
  name, 
  ipv4, 
  status
) VALUES (
  $1::text, $2::text, $3::int
)
RETURNING id, name, ipv4, status, created_at, update_at
`

type CreateServerParams struct {
	Name   string
	Ipv4   string
	Status int32
}

func (q *Queries) CreateServer(ctx context.Context, arg CreateServerParams) (Server, error) {
	row := q.db.QueryRow(ctx, createServer, arg.Name, arg.Ipv4, arg.Status)
	var i Server
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Ipv4,
		&i.Status,
		&i.CreatedAt,
		&i.UpdateAt,
	)
	return i, err
}

const deleteServer = `-- name: DeleteServer :exec
DELETE FROM servers 
WHERE id = $1
`

func (q *Queries) DeleteServer(ctx context.Context, id int64) error {
	_, err := q.db.Exec(ctx, deleteServer, id)
	return err
}

const getAllServers = `-- name: GetAllServers :many
SELECT id, name, ipv4, status, created_at, update_at FROM servers
`

func (q *Queries) GetAllServers(ctx context.Context) ([]Server, error) {
	rows, err := q.db.Query(ctx, getAllServers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Server
	for rows.Next() {
		var i Server
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Ipv4,
			&i.Status,
			&i.CreatedAt,
			&i.UpdateAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getServer = `-- name: GetServer :many
SELECT id, name, ipv4, status, created_at, update_at FROM servers
WHERE true
    AND (CASE WHEN $3::bool THEN id = $4::int ELSE TRUE END)
    AND (CASE WHEN $5::bool THEN name = $6::text ELSE TRUE END) -- :if @name
    AND (CASE WHEN $7::bool THEN status = $8::int ELSE TRUE END) -- :if @status
    AND (CASE WHEN $9::bool THEN ipv4 = $10::text ELSE TRUE END) -- :if @ipv4
ORDER BY
    CASE WHEN $11::bool THEN id END ASC, -- :if @id_asc
    CASE WHEN $12::bool  THEN id END DESC, -- :if @id_desc
    CASE WHEN $13::bool  THEN name END ASC, -- :if @name_asc
    CASE WHEN $14::bool  THEN name END DESC, -- :if @name_desc
    CASE WHEN $15::bool  THEN status END ASC, -- :if @status_asc
    CASE WHEN $16::bool  THEN status END DESC, -- :if @status_desc
    CASE WHEN $17::bool  THEN ipv4 END ASC, -- :if @ipv4_asc
    CASE WHEN $18::bool  THEN ipv4 END DESC, -- :if @ipv4_desc
    CASE WHEN $19::bool  THEN created_at END ASC, -- :if @created_at_asc
    CASE WHEN $20::bool  THEN created_at END DESC, -- :if @created_at_desc
    CASE WHEN $21::bool  THEN update_at END ASC, -- :if @updated_at_asc
    CASE WHEN $22::bool  THEN update_at END DESC -- :if @updated_at_desc
LIMIT $1
OFFSET $2
`

type GetServerParams struct {
	Limit         int32
	Offset        int32
	IsID          bool
	ID            int32
	IsName        bool
	Name          string
	IsStatus      bool
	Status        int32
	IsIpv4        bool
	Ipv4          string
	IDAsc         bool
	IDDesc        bool
	NameAsc       bool
	NameDesc      bool
	StatusAsc     bool
	StatusDesc    bool
	Ipv4Asc       bool
	Ipv4Desc      bool
	CreatedAtAsc  bool
	CreatedAtDesc bool
	UpdatedAtAsc  bool
	UpdatedAtDesc bool
}

func (q *Queries) GetServer(ctx context.Context, arg GetServerParams) ([]Server, error) {
	rows, err := q.db.Query(ctx, getServer,
		arg.Limit,
		arg.Offset,
		arg.IsID,
		arg.ID,
		arg.IsName,
		arg.Name,
		arg.IsStatus,
		arg.Status,
		arg.IsIpv4,
		arg.Ipv4,
		arg.IDAsc,
		arg.IDDesc,
		arg.NameAsc,
		arg.NameDesc,
		arg.StatusAsc,
		arg.StatusDesc,
		arg.Ipv4Asc,
		arg.Ipv4Desc,
		arg.CreatedAtAsc,
		arg.CreatedAtDesc,
		arg.UpdatedAtAsc,
		arg.UpdatedAtDesc,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Server
	for rows.Next() {
		var i Server
		if err := rows.Scan(
			&i.ID,
			&i.Name,
			&i.Ipv4,
			&i.Status,
			&i.CreatedAt,
			&i.UpdateAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateServer = `-- name: UpdateServer :one
UPDATE servers 
SET 
    name = CASE WHEN $2::bool THEN $3::text ELSE name END, -- :if @name
    status = CASE WHEN $4::bool THEN $5::int ELSE status END, -- :if @status
    ipv4 = CASE WHEN $6::bool THEN $7::text ELSE ipv4 END, -- :if @ipv4
    update_at = CASE WHEN $8::bool THEN $9::timestamp ELSE update_at END -- :if @update_at
WHERE id = $1
RETURNING id, name, ipv4, status, created_at, update_at
`

type UpdateServerParams struct {
	ID          int64
	SetName     bool
	Name        string
	SetStatus   bool
	Status      int32
	SetIpv4     bool
	Ipv4        string
	SetUpdateAt bool
	UpdateAt    pgtype.Timestamp
}

func (q *Queries) UpdateServer(ctx context.Context, arg UpdateServerParams) (Server, error) {
	row := q.db.QueryRow(ctx, updateServer,
		arg.ID,
		arg.SetName,
		arg.Name,
		arg.SetStatus,
		arg.Status,
		arg.SetIpv4,
		arg.Ipv4,
		arg.SetUpdateAt,
		arg.UpdateAt,
	)
	var i Server
	err := row.Scan(
		&i.ID,
		&i.Name,
		&i.Ipv4,
		&i.Status,
		&i.CreatedAt,
		&i.UpdateAt,
	)
	return i, err
}
